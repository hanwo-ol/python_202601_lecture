# NumPy

## 1. NumPy 배열(ndarray)의 정의 및 특징

NumPy의 핵심은 `ndarray`(N-dimensional Array) 객체입니다. 파이썬의 기본 리스트(List)와 유사해 보이나, 메모리 저장 방식과 연산 구조에서 명확한 차이를 가집니다.

*   **동질성 (Homogeneity):** 파이썬 리스트는 다양한 데이터 타입(정수, 문자열, 객체 등)을 혼합하여 저장할 수 있으나, `ndarray`는 **단일 데이터 타입**의 요소만 저장할 수 있습니다.
*   **고정된 크기 (Fixed Size):** 생성 시 크기가 결정됩니다. 요소를 추가하거나 삭제할 경우, 새로운 배열을 생성하여 메모리를 다시 할당하는 방식이 적용됩니다.
*   **연속된 메모리 배치:** 데이터가 메모리 상에 물리적으로 연속되어 저장되므로, CPU의 캐시 효율이 높고 데이터 접근 속도가 빠릅니다.
*   **벡터화 연산 (Vectorization):** 반복문(Loop) 없이 배열 전체 데이터에 대해 일괄 연산을 수행할 수 있습니다.

## 2. ndarray의 핵심 속성 (Attributes)

배열의 구조를 파악하기 위해 확인해야 할 필수 속성들입니다. 데이터의 차원과 형태를 이해하는 지표가 됩니다.

*   **`ndarray.ndim`:** 배열의 차원(Dimension) 수 또는 축(Axis)의 개수입니다.
    *   0: 스칼라 (Scalar)
    *   1: 벡터 (Vector, 1차원)
    *   2: 행렬 (Matrix, 2차원)
    *   3 이상: 텐서 (Tensor, 다차원)
*   **`ndarray.shape`:** 배열의 형태를 나타내는 튜플(Tuple)입니다. 각 차원의 크기를 나타냅니다.
    *   예: `(2, 3)`은 2행 3열의 2차원 배열을 의미합니다.
*   **`ndarray.size`:** 배열에 포함된 총 요소의 개수입니다. `shape`의 모든 값을 곱한 결과와 같습니다.
*   **`ndarray.dtype`:** 배열 내 요소들의 데이터 타입입니다. (예: `int64`, `float32`, `bool`)

## 3. 배열의 생성 및 데이터 타입

### 3.1. 생성 방식
*   **`np.array(sequence)`:** 리스트나 튜플 등 파이썬 시퀀스 데이터를 `ndarray`로 변환합니다.
*   **`np.zeros(shape)` / `np.ones(shape)`:** 지정된 형태의 배열을 생성하고 모든 값을 0 또는 1로 초기화합니다.
*   **`np.arange(start, stop, step)`:** 특정 범위 내에서 일정 간격의 값을 가진 배열을 생성합니다.
*   **`np.linspace(start, stop, num)`:** 특정 범위 내에서 균등한 간격으로 나누어진 `num`개의 값을 생성합니다.

### 3.2. 주요 데이터 타입 (dtype)
메모리 효율과 정밀도 제어를 위해 C언어 기반의 데이터 타입을 사용합니다.
*   **`int` (정수형):** `int8`, `int16`, `int32`, `int64` (숫자는 비트 수)
*   **`float` (부동소수점형):** `float16`, `float32`, `float64`
*   **`bool` (불리언):** `True` / `False`
*   **타입 변환:** `astype()` 메서드를 사용하여 기존 배열의 데이터 타입을 변경할 수 있습니다. (예: `arr.astype(np.float32)`)

## 4. 인덱싱(Indexing)과 슬라이싱(Slicing)

데이터에 접근하고 추출하는 방법입니다. 크롤링한 데이터를 정제하거나 특정 부분만 잘라낼 때 필수적입니다.

### 4.1. 기본 인덱싱
*   **1차원 배열:** `arr[index]` 형태로 접근합니다. (0부터 시작)
*   **다차원 배열:** 콤마(`,`)를 사용하여 각 차원의 인덱스를 지정합니다.
    *   문법: `arr[행_인덱스, 열_인덱스]`
    *   *참고: 파이썬 리스트의 `list[행][열]` 방식과 구분됩니다.*

### 4.2. 슬라이싱 (Slicing)
배열의 일부분을 잘라내어 새로운 뷰(View)를 반환합니다.
*   **문법:** `arr[start:stop:step]`
    *   `start`: 시작 인덱스 (포함)
    *   `stop`: 종료 인덱스 (미포함)
    *   `step`: 간격 (생략 가능)
*   **다차원 슬라이싱:** 각 차원별로 슬라이싱 범위를 지정합니다.
    *   예: `arr[:2, 1:3]` (0~1행, 1~2열 추출)

### 4.3. 팬시 인덱싱 (Fancy Indexing)
정수 배열이나 리스트를 인덱스로 사용하여 불연속적인 데이터를 추출합니다.
*   예: `arr[[0, 2, 4]]` (0번, 2번, 4번 인덱스의 값을 추출)

### 4.4. 불리언 인덱싱 (Boolean Indexing)
조건식(True/False)을 기반으로 데이터를 필터링합니다. 데이터 분석에서 가장 빈번하게 사용됩니다.
*   **원리:** 배열에 조건 연산자를 적용하면 `True`/`False`로 구성된 동일한 형태의 마스크 배열이 생성됩니다. 이 마스크를 인덱스로 사용합니다.
*   **예시:** `arr[arr > 50]` (배열 내 값이 50보다 큰 요소만 추출)

## 5. 연산 구조: 브로드캐스팅 (Broadcasting)

NumPy의 가장 강력한 특징 중 하나로, 형태(Shape)가 다른 배열 간의 연산을 가능하게 하는 규칙입니다.

### 5.1. 요소별 연산 (Element-wise Operation)
동일한 형태를 가진 배열끼리의 사칙연산은, 같은 위치(인덱스)에 있는 요소끼리 계산됩니다.

### 5.2. 브로드캐스팅 규칙
서로 다른 형태의 배열을 연산할 때, NumPy는 작은 배열을 큰 배열의 형태에 맞게 자동으로 확장(복제)하여 연산을 수행합니다.
*   **조건:** 다음 중 하나를 만족해야 합니다.
    1.  축의 크기가 일치한다.
    2.  축의 크기 중 하나가 1이다.
*   **예시:** `(3, 3)` 크기의 행렬과 `(1, 3)` 크기의 벡터를 더하면, 벡터가 행 단위로 3번 복제되어 덧셈이 수행됩니다.

## 6. 배열의 형태 변경 (Reshaping)

이미 생성된 배열의 차원이나 구조를 변경합니다. 단, 전체 요소의 개수(`size`)는 변하지 않아야 합니다.

*   **`reshape(new_shape)`:** 데이터 변경 없이 차원과 형태만 바꿉니다.
    *   예: `arr.reshape(2, 5)` (10개의 요소를 가진 1차원 배열을 2행 5열로 변경)
    *   `-1` 사용: 한 쪽의 크기만 지정하고 나머지를 `-1`로 두면, 남은 차원의 크기를 자동으로 계산합니다.
*   **`flatten()` / `ravel()`:** 다차원 배열을 1차원 배열로 평탄화합니다.
