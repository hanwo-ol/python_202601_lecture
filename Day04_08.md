# 4일차

- 자료구조 2일차
- 알고리즘 1일차
  - 예시 csv [예시.csv](https://github.com/user-attachments/files/24487746/default.csv)


---

# 종합전형 생각하시는 분들 생각해보면 좋은 내용

## "어차피 GPT, Gemini, Claude 등의 AI가 코딩해주는데, 왜 우리가 코딩을 배워야 할까?"
> [https://www.youtube.com/watch?v=7ZJ4oo4h8vI]

> 컴퓨팅 사고, 문제 해결, 코딩의 기초를 알아야 하는 이유도 얻어가실 수 있습니다.

---

# [알고리즘 보충 학습 자료]

## 1. 알고리즘의 기초와 효율성 (Big O Notation)

**정의:**
알고리즘(Algorithm)이란 입력을 받아 명확하게 정의된 일련의 규칙과 절차를 거쳐 원하는 출력을 도출해 내는 과정입니다.

**시간 복잡도 (Time Complexity)와 Big O:**
알고리즘의 성능은 '데이터의 개수($N$)가 늘어날 때, 연산 횟수가 어떻게 증가하는가'로 측정합니다. 이를 점근 표기법(Big O Notation)으로 표현합니다.

### 비교 예제: 1부터 $N$까지의 합 구하기

**방법 A: 반복문 사용 (Iterative)**
*   **논리:** 1부터 $N$까지 숫자를 하나씩 더합니다.
*   **분석:** $N$이 100이면 100번, 1억이면 1억 번 연산합니다. 입력 크기에 비례하여 시간이 증가합니다.
*   **시간 복잡도:** $O(N)$ (선형 시간)

```python
def sum_iterative(n):
    total = 0
    for i in range(1, n + 1):
        total += i
    return total
```

**방법 B: 가우스 공식 사용 (Mathematical)**
*   **논리:** 등차수열의 합 공식 $\frac{n(n+1)}{2}$을 사용합니다.
*   **분석:** $N$이 100이든 1억이든 덧셈, 곱셈, 나눗셈 총 3번의 연산만 수행합니다.
*   **시간 복잡도:** $O(1)$ (상수 시간)

```python
def sum_formula(n):
    return n * (n + 1) // 2
```

> **결론:** 컴퓨터의 처리 속도가 아무리 빨라도, 비효율적인 알고리즘($O(N)$)은 데이터가 커지면 수학적 접근($O(1)$)을 절대 이길 수 없습니다.

---

## 2. 탐색 알고리즘 (Search)

데이터 집합에서 특정 값을 찾는 방법입니다. 데이터의 정렬 상태에 따라 사용할 수 있는 알고리즘이 달라집니다.

### 2.1. 선형 탐색 (Linear Search)
*   **개념:** 리스트의 첫 번째 요소부터 끝까지 순차적으로 확인합니다.
*   **조건:** 데이터가 정렬되어 있지 않아도 사용 가능합니다.
*   **효율성:** 최악의 경우 모든 데이터를 확인해야 하므로 $O(N)$입니다.

```python
def linear_search(data, target):
    # 리스트 전체를 순회
    for i in range(len(data)):
        if data[i] == target:
            return i  # 찾은 위치(인덱스) 반환
    return -1  # 찾지 못함
```

### 2.2. 이진 탐색 (Binary Search) ★ 핵심
*   **개념:** 탐색 범위를 절반씩 줄여나가는 방식입니다. (Up/Down 게임과 동일한 논리)
*   **조건:** **데이터가 반드시 오름차순으로 정렬(Sorted)되어 있어야 합니다.**
*   **효율성:** 확인할 때마다 데이터가 절반으로 줄어듭니다. 데이터가 100만 개라도 약 20번($\log_2 1,000,000 \approx 19.9$)이면 찾을 수 있습니다. $O(\log N)$입니다.

```python
def binary_search(data, target):
    start = 0
    end = len(data) - 1

    while start <= end:
        mid = (start + end) // 2  # 중간 인덱스 계산
        
        if data[mid] == target:
            return mid  # 찾음
        elif data[mid] > target:
            end = mid - 1  # 중간값보다 작으므로 왼쪽 구역 선택
        else:
            start = mid + 1  # 중간값보다 크므로 오른쪽 구역 선택
            
    return -1  # 찾지 못함
```

---

## 3. 정렬 알고리즘 (Sort)

데이터를 순서대로 나열하는 알고리즘입니다. 파이썬의 `sort()` 함수를 쓰지 않고 직접 구현함으로써 이중 반복문과 인덱스 조작 능력을 훈련합니다.

### 선택 정렬 (Selection Sort)
*   **개념:**
    1.  전체 범위에서 '최솟값'을 찾습니다.
    2.  그 최솟값을 범위의 '맨 앞' 데이터와 교환(Swap)합니다.
    3.  맨 앞을 제외한 나머지 범위에서 위 과정을 반복합니다.
*   **학습 목표:** 중첩 루프(`nested loop`)의 흐름과 두 변수의 값을 바꾸는 스왑 패턴을 익힙니다.
*   **효율성:** $O(N^2)$

```python
def selection_sort(data):
    n = len(data)
    # i는 정렬된 부분이 채워질 위치
    for i in range(n - 1):
        min_idx = i  # 일단 i번째가 가장 작다고 가정
        
        # i 뒤의 나머지 부분에서 실제 최솟값 탐색
        for j in range(i + 1, n):
            if data[j] < data[min_idx]:
                min_idx = j
        
        # 최솟값이 있는 위치(min_idx)와 현재 위치(i)의 값을 교환(Swap)
        data[i], data[min_idx] = data[min_idx], data[i]
        
    return data

# 테스트
sample = [29, 10, 14, 37, 13]
print(f"정렬 전: {sample}")
print(f"정렬 후: {selection_sort(sample)}")
```

---

## 4. 재귀 함수 (Recursion)

함수가 자기 자신을 다시 호출하여 작업을 수행하는 방식입니다.

*   **구조:**
    1.  **종료 조건 (Base Case):** 재귀 호출을 멈추는 조건. (없으면 무한 루프 발생)
    2.  **재귀 단계 (Recursive Step):** 문제를 더 작은 단위로 쪼개어 자기 자신을 호출.

### 예제: 팩토리얼 (Factorial)
수학적 정의: $N! = N \times (N-1)!$ (단, $1! = 1, 0! = 1$)

```python
def factorial(n):
    # 1. 종료 조건 (Base Case)
    if n <= 1:
        return 1
    
    # 2. 재귀 단계 (Recursive Step)
    return n * factorial(n - 1)

# 실행 과정 예시: factorial(3)
# 3 * factorial(2)
# 3 * (2 * factorial(1))
# 3 * (2 * 1)
# 6
```

### 주의사항
재귀 함수는 코드를 간결하게 만들지만, 호출이 깊어지면 메모리(Stack) 사용량이 증가하여 `RecursionError`가 발생할 수 있습니다. 반복문으로 해결 가능한 문제는 반복문이 성능상 유리한 경우가 많습니다.

---

### [학습 요약]
1.  **효율성:** 문제를 푸는 것보다 '빠르게' 푸는 것이 중요하며, 이는 반복 횟수($O$)로 결정된다.
2.  **탐색:** 정렬되지 않은 데이터는 선형 탐색($O(N)$), 정렬된 데이터는 이진 탐색($O(\log N)$)을 사용한다.
3.  **정렬:** 데이터를 순서대로 배치하는 논리적 과정을 직접 코드로 구현할 수 있어야 한다.
4.  **재귀:** 큰 문제를 작은 문제의 반복으로 정의하여 해결한다. 종료 조건이 필수적이다.
