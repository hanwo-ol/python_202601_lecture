# 리스트 인덱싱 및 슬라이싱 기술 설명서

리스트는 순서가 있는 시퀀스(Sequence) 자료형이므로, 각 요소는 고유한 위치 값을 가집니다. 이 위치 값을 통해 데이터에 접근(Indexing)하거나, 특정 구간을 추출(Slicing)하는 것이 가능합니다.

## 1. 인덱싱 (Indexing)

**정의:**
리스트 내의 특정 위치(오프셋, Offset)에 있는 **단일 요소**에 접근하는 연산입니다.

**수학적 개념:**
길이가 $N$인 유한 수열 $L = (a_0, a_1, \dots, a_{N-1})$이 있을 때, 정수 $i$에 대하여 $L[i]$는 수열의 $i$번째 항 $a_i$를 반환하는 함수적 매핑입니다.

**주요 원칙:**

1.  **0-based Indexing (0부터 시작):**
    컴퓨터 메모리의 오프셋 개념에 따라 첫 번째 요소의 인덱스는 $0$입니다.
    *   첫 번째 요소: $L[0]$
    *   $n$번째 요소: $L[n-1]$

2.  **Negative Indexing (음수 인덱싱):**
    파이썬은 수열의 끝에서부터 역순으로 접근하는 음수 인덱스를 지원합니다.
    *   마지막 요소: $L[-1]$
    *   뒤에서 $k$번째 요소: $L[-k]$
    *   수학적으로 $L[-k]$는 $L[N-k]$와 등가입니다 ($N$은 리스트의 길이).

3.  **유효 범위 (Valid Range):**
    인덱스 $i$의 유효 범위는 다음과 같습니다. 범위를 벗어날 경우 `IndexError` 예외가 발생합니다.
    *   $-N \le i \le N-1$

**코드 예시:**
```python
# 길이 N=5인 리스트
data = [10, 20, 30, 40, 50]

# 정방향 접근 (0 ~ 4)
first_val = data[0]   # 10
third_val = data[2]   # 30

# 역방향 접근 (-1 ~ -5)
last_val = data[-1]   # 50
prev_val = data[-2]   # 40

# 범위 초과 (오류 발생)
# error_val = data[5] # IndexError: list index out of range
```

---

## 2. 슬라이싱 (Slicing)

**정의:**
리스트의 특정 범위에 해당하는 요소들을 추출하여 **새로운 리스트 객체**를 생성하는 연산입니다.

**문법 (Syntax):**
`List[start : stop : step]`
*   `start`: 시작 인덱스 (포함)
*   `stop`: 종료 인덱스 (미포함)
*   `step`: 증감폭 (선택 사항, 기본값 1)

**수학적 개념:**
1.  **반개구간 (Half-open Interval):**
    슬라이싱 범위 `[start:stop]`은 수학의 반개구간 $[start, stop)$에 해당합니다.
    *   즉, $\{x \in \mathbb{Z} \mid start \le x < stop\}$ 범위의 인덱스를 선택합니다.
    *   종료 인덱스 `stop`은 결과에 포함되지 않습니다.

2.  **등차수열 (Arithmetic Progression):**
    `step`이 주어진 경우, 인덱스는 초항이 $start$이고 공차가 $step$인 등차수열을 이룹니다.
    *   선택되는 인덱스 집합: $I = \{ start, start + step, start + 2 \cdot step, \dots \}$
    *   단, 해당 인덱스는 반드시 $start$와 $stop$ 사이의 구간에 존재해야 합니다.

**주요 특징:**

1.  **기본값 처리 (Omission):**
    *   `start` 생략 시: $0$ (처음부터)
    *   `stop` 생략 시: $N$ (끝까지)
    *   `step` 생략 시: $1$

2.  **음수 Step (역순 추출):**
    `step`이 음수일 경우 리스트를 역순으로 탐색합니다. 이 경우 기본 `start`는 $-1$(마지막), `stop`은 $-\infty$(첫 요소 이전)로 설정됩니다.

3.  **범위 초과 처리:**
    인덱싱과 달리 슬라이싱은 범위를 벗어난 인덱스를 지정해도 오류(`IndexError`)가 발생하지 않습니다. 유효한 범위 내의 교집합 부분만 반환하며, 겹치는 부분이 없으면 빈 리스트 `[]`를 반환합니다.

4.  **객체 복사:**
    슬라이싱의 결과는 원본 리스트의 부분집합을 가진 **새로운 리스트(Shallow Copy)**입니다.

**코드 예시:**
```python
# 길이 N=10인 리스트 (0부터 9까지)
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 1. 기본 슬라이싱 [start, stop)
sub1 = nums[2:5]    # [2, 3, 4] -> 인덱스 2, 3, 4 선택 (5 제외)

# 2. 생략 표기
sub2 = nums[:3]     # [0, 1, 2] -> 처음부터 인덱스 3 직전까지
sub3 = nums[7:]     # [7, 8, 9] -> 인덱스 7부터 끝까지

# 3. Step 활용 (등차수열)
sub4 = nums[1:8:2]  # [1, 3, 5, 7] -> 인덱스 1부터 2씩 증가 (1, 3, 5, 7)

# 4. 역순 슬라이싱
sub5 = nums[::-1]   # [9, 8, ..., 0] -> 리스트 전체 뒤집기
sub6 = nums[5:2:-1] # [5, 4, 3] -> 인덱스 5부터 2 직전까지 역순

# 5. 범위 초과 (오류 없음)
sub7 = nums[8:20]   # [8, 9] -> 유효한 구간만 반환
```

---

## 요약: 인덱싱 vs 슬라이싱

| 구분 | 인덱싱 (Indexing) | 슬라이싱 (Slicing) |
| :--- | :--- | :--- |
| **반환 타입** | 해당 요소의 자료형 (int, str 등) | 항상 **리스트 (List)** |
| **접근 대상** | 단일 요소 (Scalar) | 요소의 부분집합 (Vector) |
| **수학적 표기** | $a_i$ | $\{a_i \mid i \in [start, stop), i \equiv start \pmod{step}\}$ |
| **범위 오류** | 발생함 (`IndexError`) | 발생 안 함 (빈 리스트 반환 가능) |
