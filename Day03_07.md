연산자 복습하러 가기 > [https://github.com/hanwo-ol/python_202601_lecture/blob/main/Day02_06.md#%EC%B2%AB-%EC%8B%9C%EA%B0%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%97%B0%EC%82%B0%EC%9E%90%EB%93%A4%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90]

# 2026년 1월 7일 수업

# 공지사항

공식적인 수업 종료 시각은 `오후 5시 50분` 입니다.

화으이팅..

---

# 📝 Python 코딩 자습서: 기초부터 광기까지

## 문제 1: 두 실수 중에서 큰 값 찾기
> **조건:** `a`, `b`는 실수(float)로 입력받음.

### 1. 정석적인 코딩 (Standard & Compact)
가장 파이썬답고 가독성이 좋은 코드입니다. 파이썬 내장 함수를 활용합니다.

```python
# 입력 받기
a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설] max() 함수는 인자 중 가장 큰 값을 반환합니다.
# 가장 직관적이고 실무에서 사용하는 방식입니다.
result = max(a, b)

print(f"더 큰 수는: {result}")
```

### 2. 이게 뭐야 싶은 어이없는 코딩 (The absurd)
"간단한 걸 복잡하게 만드는 재주"가 있는 코드입니다. 리스트를 만들고, 정렬하고, 반복문을 굳이 씁니다.

```python
import sys

a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설]
# 1. 굳이 리스트에 담습니다.
# 2. sort()로 정렬을 합니다. (작은 거 -> 큰 거 순서)
# 3. pop()으로 맨 뒤(큰 거)를 뽑습니다.
# 4. 이걸 굳이 while 문에 넣어서 True일 때 한 번만 돌리고 break로 끕니다.
temp_list = [a, b]
result = 0

while True:
    temp_list.sort()
    result = temp_list.pop()
    break # 왜 반복문을 쓴 걸까요?

print(f"더 큰 수는(어렵게 구함): {result}")
```

### 3. 극한의 효율/수학적 코딩 (Extreme Efficiency)
조건문(`if`)조차 쓰기 싫을 때 사용하는 순수 수학적 접근입니다. (사실 `max`가 제일 빠르지만, 알고리즘적으로 분기 없이 처리하는 방식입니다.)

```python
a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설]
# 두 수의 합에 차이의 절댓값을 더한 뒤 2로 나누면 큰 수가 나옵니다.
# (a + b + |a - b|) / 2
# 분기문(if) 없이 CPU 연산만으로 처리하므로 로우 레벨 언어에서 최적화할 때 쓰는 기법입니다.
result = (a + b + abs(a - b)) / 2

print(f"더 큰 수는: {result}")
```

---

## 문제 2: 1부터 n까지의 짝수 합과 평균 구하기
> **조건:** `n`은 입력받음. (평균 = 짝수들의 합 / 짝수들의 개수)

### 1. 정석적인 코딩 (Standard)
초보자가 반복문의 흐름을 이해하기 가장 좋은 교과서적인 코드입니다.

```python
n = int(input("n 입력: "))

sum_even = 0  # 합계 변수
count = 0     # 개수 변수

# 1부터 n까지 반복
for i in range(1, n + 1):
    if i % 2 == 0:        # 짝수라면
        sum_even += i     # 더하고
        count += 1        # 개수 세기

# 0으로 나누기 방지 (n이 1일 경우 등)
if count == 0:
    print("짝수가 없습니다.")
else:
    avg = sum_even / count
    print(f"합계: {sum_even}, 평균: {avg}")
```

### 2. 이게 뭐야 싶은 어이없는 코딩 (The absurd)
컴퓨터를 고문하는 방식입니다. 숫자를 문자열로 바꾸고, 다시 숫자로 바꾸며 자원을 낭비합니다.

```python
n = int(input("n 입력: "))

even_list = []

# [해설]
# 1. range를 쓰면서 굳이 while로 인덱스를 관리합니다.
# 2. 숫자가 짝수인지 알기 위해 숫자를 문자열(str)로 바꿉니다.
# 3. 문자열의 마지막 글자가 '0,2,4,6,8' 중 하나인지 검사합니다.
# 4. 맞으면 다시 정수(int)로 바꿔서 리스트에 넣습니다.

i = 1
while i <= n:
    str_num = str(i)
    if str_num[-1] in ['0', '2', '4', '6', '8']: # 극한의 비효율
        even_list.append(int(str_num))
    i += 1

if not even_list:
    print("짝수 없음")
else:
    # sum() 함수를 안 쓰고 굳이 또 반복문으로 합을 구합니다.
    total = 0
    for num in even_list:
        total += num
    
    print(f"합계: {total}, 평균: {total / len(even_list)}")
```

### 3. 극한의 효율적인 코딩 (Extreme Efficiency)
반복문을 아예 쓰지 않습니다. $O(1)$의 시간 복잡도를 가지며, n이 100억이어도 0.00001초 만에 답이 나옵니다. 등차수열의 성질을 이용합니다.

```python
n = int(input("n 입력: "))

# [해설]
# 1. 1~n까지 짝수의 개수(k)는 n // 2 개입니다.
# 2. 첫 짝수는 2, 마지막 짝수는 2*k 입니다.
# 3. 짝수들의 합 공식: k * (k + 1)
# 4. 짝수들의 평균 공식: k + 1 (합 / 개수 이므로)

if n < 2:
    print("짝수가 없습니다.")
else:
    k = n // 2           # 짝수의 개수
    total_sum = k * (k + 1)
    avg = k + 1
    
    print(f"합계: {total_sum}, 평균: {float(avg)}")
```

---

# 파이썬 데이터 구조 기술 설명서

## 1. 리스트 (List)
**정의:** 순서가 존재하고(Ordered), 내용을 변경할 수 있는(Mutable) 가변 시퀀스 자료형입니다. 데이터의 중복을 허용합니다.

**수학적 개념:**
유한 수열(Finite Sequence) 또는 벡터(Vector)와 유사합니다.
*   $L = (a_1, a_2, a_3, ..., a_n)$
*   인덱스 $i$에 대하여 $L[i] = a_{i+1}$ (파이썬은 0-based indexing이므로)

**특징:**
*   **가변성:** 할당된 메모리 공간 내에서 요소를 추가, 삭제, 수정할 수 있습니다.
*   **동적 배열:** 데이터 크기에 따라 메모리가 자동으로 재할당됩니다.
*   **다형성:** 하나의 리스트 안에 정수, 실수, 문자열 등 다른 타입의 데이터를 혼합하여 저장할 수 있습니다.

**코드 예시 (벡터 연산의 기초):**
```python
# 3차원 벡터 두 개의 정의
vector_a = [1.0, 2.0, 3.0]
vector_b = [4.0, 5.0, 6.0]

# 요소 수정 (Mutable)
vector_a[0] = 10.0  # [10.0, 2.0, 3.0]으로 변경됨

# 데이터 추가
vector_a.append(4.0) # [10.0, 2.0, 3.0, 4.0]
```

---

## 2. 튜플 (Tuple)
**정의:** 순서가 존재하지만(Ordered), 내용을 변경할 수 없는(Immutable) 불변 시퀀스 자료형입니다. 데이터의 중복을 허용합니다.

**수학적 개념:**
수학에서의 n-튜플(n-tuple) 또는 순서쌍(Ordered Pair)과 동일합니다. 정의된 이후에는 성분이 변하지 않는 상수 벡터로 볼 수 있습니다.
*   2차원 좌표: $P = (x, y)$
*   상수 집합의 순서쌍: $T = (c_1, c_2, ..., c_n)$

**특징:**
*   **불변성:** 생성 시점에 값이 고정되며, 이후 추가, 삭제, 수정이 불가능합니다.
*   **성능:** 리스트에 비해 메모리 사용량이 적고, 순회 속도가 빠릅니다.
*   **해시 가능:** 불변이므로 딕셔너리의 키(Key)나 세트의 요소로 사용할 수 있습니다.

**코드 예시 (좌표 평면):**
```python
# 점 P와 Q의 좌표 (변경 불가능한 상수로 취급)
point_p = (2, 3)
point_q = (5, 7)

# 인덱싱 (가능)
x_val = point_p[0] 

# 값 할당 시도 (불가능 - TypeError 발생)
# point_p[0] = 10 
```

---

## 3. 세트 (Set)
**정의:** 순서가 없고(Unordered), 중복된 데이터를 허용하지 않는(Unique) 가변 자료형입니다.

**수학적 개념:**
수학의 집합(Set) 그 자체입니다.
*   $S = \{x \mid x \in \text{Integers}, 1 \le x \le 5\}$
*   교집합($A \cap B$), 합집합($A \cup B$), 차집합($A - B$) 연산을 지원합니다.

**특징:**
*   **중복 제거:** 동일한 값을 여러 번 넣어도 내부에 유일한 값 하나만 유지됩니다.
*   **순서 없음:** 인덱스(Index)가 존재하지 않아 `S[0]`과 같은 접근이 불가능합니다.
*   **해시 테이블:** 내부적으로 해시 테이블을 사용하여 데이터 검색 속도가 $O(1)$로 매우 빠릅니다.

**코드 예시 (집합 연산):**
```python
set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}

# 교집합 (Intersection): {3, 4}
intersection = set_a & set_b 

# 합집합 (Union): {1, 2, 3, 4, 5, 6}
union = set_a | set_b

# 차집합 (Difference): {1, 2}
difference = set_a - set_b
```

---

## 4. 딕셔너리 (Dictionary)
**정의:** 키(Key)와 값(Value)의 쌍으로 이루어진 가변 자료형입니다. 키는 고유해야 하며 불변(Immutable)이어야 합니다.

**수학적 개념:**
정의역(Domain)이 키(Key)이고 공역(Codomain)이 값(Value)인 함수(Function) 또는 사상(Mapping)과 유사합니다.
*   $f: K \to V$
*   $y = f(x)$ 에서 $x$는 Key, $y$는 Value에 해당합니다.
*   단, 하나의 $x$는 오직 하나의 $y$에만 대응해야 합니다(키의 유일성).

**특징:**
*   **키-값 구조:** 인덱스가 아닌 키를 통해 값에 접근합니다.
*   **해시 구조:** 키를 해싱하여 값을 저장하므로 검색 및 접근 속도가 빠릅니다.
*   **키의 제약:** 키는 문자열, 숫자, 튜플 등 불변 객체만 가능하지만, 값은 리스트 등 가변 객체를 포함한 모든 타입이 가능합니다.

**코드 예시 (함수적 매핑):**
```python
# f(x) = x^2 꼴의 매핑 데이터
func_map = {1: 1, 2: 4, 3: 9, 4: 16}

# 값 조회 (함수값 계산과 유사)
y_val = func_map[3]  # 9

# 새로운 매핑 추가
func_map[5] = 25

# 키 확인
exists = 2 in func_map  # True (정의역에 2가 존재하는지 확인)
```

---

## 요약 비교

| 자료구조 | 가변성 (Mutability) | 순서 (Order) | 중복 허용 (Duplication) | 접근 방식 |
| :--- | :--- | :--- | :--- | :--- |
| **List** | 가변 (Mutable) | 있음 | 허용함 | 정수 인덱스 ($0, 1, ...$) |
| **Tuple** | 불변 (Immutable) | 있음 | 허용함 | 정수 인덱스 ($0, 1, ...$) |
| **Set** | 가변 (Mutable) | 없음 | 허용 안 함 | 접근 불가 (순회만 가능) |
| **Dict** | 가변 (Mutable)* | 없음 (논리적)** | 키(Key) 중복 불가 | 키 (Key) |

\* 딕셔너리의 값(Value)은 가변이지만, 구조 자체의 키-값 연결 관계는 수정 가능합니다.
\** Python 3.7+부터는 내부 구현상 삽입 순서를 보존하지만, 자료구조의 정의상 순서에 의존하지 않는 매핑(Mapping)으로 취급해야 합니다.
