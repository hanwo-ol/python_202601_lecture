연산자 복습하러 가기 > [https://github.com/hanwo-ol/python_202601_lecture/blob/main/Day02_06.md#%EC%B2%AB-%EC%8B%9C%EA%B0%84-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EC%97%B0%EC%82%B0%EC%9E%90%EB%93%A4%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90]

# 2026년 1월 7일 수업

# 공지사항

공식적인 수업 종료 시각은 `오후 5시 50분` 입니다.

화으이팅..

---

# 📝 Python 코딩 자습서: 기초부터 광기까지

## 문제 1: 두 실수 중에서 큰 값 찾기
> **조건:** `a`, `b`는 실수(float)로 입력받음.

### 1. 정석적인 코딩 (Standard & Compact)
가장 파이썬답고 가독성이 좋은 코드입니다. 파이썬 내장 함수를 활용합니다.

```python
# 입력 받기
a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설] max() 함수는 인자 중 가장 큰 값을 반환합니다.
# 가장 직관적이고 실무에서 사용하는 방식입니다.
result = max(a, b)

print(f"더 큰 수는: {result}")
```

### 2. 이게 뭐야 싶은 어이없는 코딩 (The absurd)
"간단한 걸 복잡하게 만드는 재주"가 있는 코드입니다. 리스트를 만들고, 정렬하고, 반복문을 굳이 씁니다.

```python
import sys

a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설]
# 1. 굳이 리스트에 담습니다.
# 2. sort()로 정렬을 합니다. (작은 거 -> 큰 거 순서)
# 3. pop()으로 맨 뒤(큰 거)를 뽑습니다.
# 4. 이걸 굳이 while 문에 넣어서 True일 때 한 번만 돌리고 break로 끕니다.
temp_list = [a, b]
result = 0

while True:
    temp_list.sort()
    result = temp_list.pop()
    break # 왜 반복문을 쓴 걸까요?

print(f"더 큰 수는(어렵게 구함): {result}")
```

### 3. 극한의 효율/수학적 코딩 (Extreme Efficiency)
조건문(`if`)조차 쓰기 싫을 때 사용하는 순수 수학적 접근입니다. (사실 `max`가 제일 빠르지만, 알고리즘적으로 분기 없이 처리하는 방식입니다.)

```python
a = float(input("a 입력: "))
b = float(input("b 입력: "))

# [해설]
# 두 수의 합에 차이의 절댓값을 더한 뒤 2로 나누면 큰 수가 나옵니다.
# (a + b + |a - b|) / 2
# 분기문(if) 없이 CPU 연산만으로 처리하므로 로우 레벨 언어에서 최적화할 때 쓰는 기법입니다.
result = (a + b + abs(a - b)) / 2

print(f"더 큰 수는: {result}")
```

---

## 문제 2: 1부터 n까지의 짝수 합과 평균 구하기
> **조건:** `n`은 입력받음. (평균 = 짝수들의 합 / 짝수들의 개수)

### 1. 정석적인 코딩 (Standard)
초보자가 반복문의 흐름을 이해하기 가장 좋은 교과서적인 코드입니다.

```python
n = int(input("n 입력: "))

sum_even = 0  # 합계 변수
count = 0     # 개수 변수

# 1부터 n까지 반복
for i in range(1, n + 1):
    if i % 2 == 0:        # 짝수라면
        sum_even += i     # 더하고
        count += 1        # 개수 세기

# 0으로 나누기 방지 (n이 1일 경우 등)
if count == 0:
    print("짝수가 없습니다.")
else:
    avg = sum_even / count
    print(f"합계: {sum_even}, 평균: {avg}")
```

### 2. 이게 뭐야 싶은 어이없는 코딩 (The absurd)
컴퓨터를 고문하는 방식입니다. 숫자를 문자열로 바꾸고, 다시 숫자로 바꾸며 자원을 낭비합니다.

```python
n = int(input("n 입력: "))

even_list = []

# [해설]
# 1. range를 쓰면서 굳이 while로 인덱스를 관리합니다.
# 2. 숫자가 짝수인지 알기 위해 숫자를 문자열(str)로 바꿉니다.
# 3. 문자열의 마지막 글자가 '0,2,4,6,8' 중 하나인지 검사합니다.
# 4. 맞으면 다시 정수(int)로 바꿔서 리스트에 넣습니다.

i = 1
while i <= n:
    str_num = str(i)
    if str_num[-1] in ['0', '2', '4', '6', '8']: # 극한의 비효율
        even_list.append(int(str_num))
    i += 1

if not even_list:
    print("짝수 없음")
else:
    # sum() 함수를 안 쓰고 굳이 또 반복문으로 합을 구합니다.
    total = 0
    for num in even_list:
        total += num
    
    print(f"합계: {total}, 평균: {total / len(even_list)}")
```

### 3. 극한의 효율적인 코딩 (Extreme Efficiency)
반복문을 아예 쓰지 않습니다. $O(1)$의 시간 복잡도를 가지며, n이 100억이어도 0.00001초 만에 답이 나옵니다. 등차수열의 성질을 이용합니다.

```python
n = int(input("n 입력: "))

# [해설]
# 1. 1~n까지 짝수의 개수(k)는 n // 2 개입니다.
# 2. 첫 짝수는 2, 마지막 짝수는 2*k 입니다.
# 3. 짝수들의 합 공식: k * (k + 1)
# 4. 짝수들의 평균 공식: k + 1 (합 / 개수 이므로)

if n < 2:
    print("짝수가 없습니다.")
else:
    k = n // 2           # 짝수의 개수
    total_sum = k * (k + 1)
    avg = k + 1
    
    print(f"합계: {total_sum}, 평균: {float(avg)}")
```

---
