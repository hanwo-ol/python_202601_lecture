# 넘파이 복습

## 넘파이 배열

- 동일한 자료형의 요소들로 구성된 다차원 배열
- 일반적인 리스트보다 메모리 효율이 뛰어나며, 연산속도도 훨씬 빠름
- 순서가 있는 구조임. 인덱싱과 슬라이싱을 통해 요소 접근 및 수정이 가능함
- 넘파이 배열의 자료형은 배열 요소의 자료형을 따름

> 내일 예고: 데이터 분석하면 빼놓을 수 없는 `pandas`

## 데이터 구조화

- 논리적으로 데이터를 정리해 표 형태로 만드는 것을 데이터 구조화, 정형화라고 함.


## 넘파이 배열 생성 함수
- `np.array()`
- `np.zeros()`
- `np.ones()`
- `np.arange()`

## 넘파이 배열의 속성
- `ndim`: 차원췌크
- `dtype`, `itemsize`, `size`, `nbyte`,
- `shape`: 각 차원의 크기
- `T`

## 넘파이 배열의 차원
- 스칼라: 0차원
- 벡터: 1차원
- 행렬: 2차원
- 텐서: 3차원 이상의 배열

---

# 넘파이 차원과 축

*넘파이를 쓰려면, 넘파이를 import해야함*

``` python
import numpy as np
```

# 넘파이 메소드
- `sum()`
- `mean()`
- `std()`
- `min()`, `max()`
- `cumsum()`, `cumprod()`

---

# 오늘의 실습 문제(였던 것)
## 넘파이 배열 다루기
1) 넘파이 배열 생성
2) 인덱싱과 슬라이싱: 2차원,3차원에 대해서 같이 풀고 있음
3) 조건 필터링


## 넘파이 배열 연산
1) 기본연산
2) 통계계산
3) 브로드캐스팅


---

## 1. 넘파이 배열 다루기

### 1.1. 넘파이 배열 생성 (Creation)
NumPy 배열(`ndarray`)은 파이썬 리스트를 변환하거나, 내부 생성 함수를 통해 초기화할 수 있습니다. 데이터 분석 시 가장 빈번하게 사용되는 생성 방식입니다.

*   **`np.array()`:** 리스트를 배열로 변환합니다. 데이터 타입을 추론하여 결정합니다.
*   **`np.arange()`:** 파이썬의 `range()`와 유사하게, 특정 구간의 수열을 생성합니다.
*   **`np.zeros()` / `np.ones()`:** 0 또는 1로 채워진 배열을 생성합니다. 초기값 설정에 사용됩니다.
*   **`reshape()`:** 배열의 데이터는 유지한 채 차원의 구조를 변경합니다.

```python
import numpy as np

# 1. 리스트를 통한 1차원 배열 생성
list_data = [10, 20, 30]
arr_1d = np.array(list_data)
print(f"1. array 변환: {arr_1d} (Shape: {arr_1d.shape})")

# 2. arange를 통한 순차적 데이터 생성 (0부터 11까지)
sequence_data = np.arange(12)
print(f"2. arange 생성: {sequence_data}")

# 3. Reshape: 1차원 데이터를 3행 4열의 2차원 행렬로 변환
matrix_data = sequence_data.reshape(3, 4)
print(f"3. reshape(3, 4):\n{matrix_data}")

# 4. 초기화 함수 사용 (0으로 채운 2x2 행렬)
zeros_data = np.zeros((2, 2), dtype=int)
print(f"4. zeros(2, 2):\n{zeros_data}")
```

### 1.2. 인덱싱과 슬라이싱 (Indexing & Slicing)
배열 내의 특정 위치에 접근하거나 부분 집합을 추출하는 방법입니다. NumPy의 슬라이싱은 원본 데이터의 **뷰(View)**를 반환하므로 메모리 효율이 높습니다.

*   **정수 인덱싱:** `[행, 열]` 형태로 특정 위치의 값을 가져옵니다.
*   **슬라이싱:** `[시작:끝]` 형태로 범위를 지정합니다. 다차원 배열에서는 콤마(`,`)로 차원을 구분합니다.

```python
import numpy as np

# 데이터 준비: 3x3 행렬
# [[ 0,  1,  2],
#  [10, 11, 12],
#  [20, 21, 22]]
data = np.array([
    [0, 1, 2],
    [10, 11, 12],
    [20, 21, 22]
])

# 1. 정수 인덱싱 (특정 좌표 접근)
element = data[1, 2] # 1번 행(중간), 2번 열(오른쪽) -> 값: 12
print(f"1. 인덱싱 data[1, 2]: {element}")

# 2. 슬라이싱 (부분 행렬 추출)
# 0~1번 행, 1~끝 열까지
sub_matrix = data[0:2, 1:]
print(f"2. 슬라이싱 data[0:2, 1:]:\n{sub_matrix}")

# 3. 슬라이싱은 뷰(View)임 (원본 영향 확인)
sub_matrix[0, 0] = 999 
print(f"3. 부분 수정 후 원본 data:\n{data}")
# (0, 1) 위치의 값이 1에서 999로 변경됨을 확인 가능
```

### 1.3. 조건 필터링 (Boolean Indexing)
조건식(Condition)을 사용하여 `True`에 해당하는 데이터만 추출합니다. 데이터 정제(Cleaning)나 이상치 제거에 필수적입니다.

*   **원리:** 비교 연산(`>`, `<` 등)을 수행하면 `True/False`로 구성된 동일 형태의 배열(Mask)이 생성됩니다. 이를 인덱스로 사용합니다.

```python
import numpy as np

# 랜덤 정수 데이터 생성 (0~100 사이, 5개)
scores = np.array([85, 40, 92, 25, 60])
print(f"원본 점수: {scores}")

# 1. 조건 마스크 생성
mask = scores >= 60
print(f"1. 60점 이상 마스크: {mask}") # [True, False, True, False, True]

# 2. 필터링 (True인 값만 추출)
pass_scores = scores[mask]
print(f"2. 합격 점수: {pass_scores}")

# 3. 값 변경 (조건에 맞는 값만 특정 값으로 변경)
# 60점 미만은 0점으로 처리
scores[scores < 60] = 0
print(f"3. 과락 처리 후: {scores}")
```

---

## 2. 넘파이 배열 연산

### 2.1. 기본 연산 (Basic Operations)
NumPy의 산술 연산은 기본적으로 **요소별(Element-wise) 연산**을 수행합니다.

*   **사칙연산(`+`, `-`, `*`, `/`):** 같은 위치에 있는 요소끼리 계산합니다.
*   **행렬 곱(`@` 또는 `dot`):** 선형대수학의 행렬 곱셈을 수행합니다. 단순 곱셈(`*`)과 반드시 구분해야 합니다.

```python
import numpy as np

arr_a = np.array([[1, 2], [3, 4]])
arr_b = np.array([[10, 20], [30, 40]])

# 1. 요소별 덧셈
add_result = arr_a + arr_b
print(f"1. 덧셈 (Element-wise):\n{add_result}")

# 2. 요소별 곱셈 (*) -> 위치가 같은 값끼리 곱함
mul_result = arr_a * arr_b
print(f"2. 요소별 곱셈 (*):\n{mul_result}")
# [[1*10, 2*20], [3*30, 4*40]] -> [[10, 40], [90, 160]]

# 3. 행렬 곱 (@) -> 내적(Dot Product) 계산
dot_result = arr_a @ arr_b
print(f"3. 행렬 곱 (@):\n{dot_result}")
# [[1*10+2*30, 1*20+2*40], ...] -> [[70, 100], [150, 220]]
```

### 2.2. 통계 계산 (Statistical Calculations)
배열 전체 또는 특정 축(`axis`)을 기준으로 통계 값을 계산합니다.

*   **`sum`, `mean`, `std`, `min`, `max`:** 합계, 평균, 표준편차, 최솟값, 최댓값.
*   **`axis` 매개변수:** 연산을 수행할 방향을 지정합니다. (2차원 기준 `axis=0`은 열 방향, `axis=1`은 행 방향)

```python
import numpy as np

# 3행 2열 데이터 (국어, 영어 점수라고 가정)
grades = np.array([
    [80, 90],  # 학생 A
    [70, 60],  # 학생 B
    [100, 80]  # 학생 C
])

# 1. 전체 평균
print(f"1. 전체 점수 평균: {grades.mean():.2f}")

# 2. 과목별 평균 (세로 방향, axis=0)
# 국어 평균, 영어 평균
subject_avg = grades.mean(axis=0)
print(f"2. 과목별 평균 (axis=0): {subject_avg}")

# 3. 학생별 합계 (가로 방향, axis=1)
# 학생 A 총점, 학생 B 총점, 학생 C 총점
student_sum = grades.sum(axis=1)
print(f"3. 학생별 총점 (axis=1): {student_sum}")
```

### 2.3. 브로드캐스팅 (Broadcasting)
형태(Shape)가 다른 두 배열 간의 연산을 가능하게 하는 메커니즘입니다. 작은 배열이 큰 배열의 형태에 맞춰 자동으로 반복(확장)됩니다.

*   **조건:** 두 배열의 각 차원 크기가 같거나, 둘 중 하나의 차원 크기가 1이어야 합니다.

```python
import numpy as np

# (3, 3) 행렬
matrix = np.array([
    [1, 1, 1],
    [2, 2, 2],
    [3, 3, 3]
])

# (3,) 벡터
vector = np.array([10, 20, 30])

# 1. 브로드캐스팅 덧셈
# 벡터 [10, 20, 30]이 각 행마다 반복되어 더해짐
# 1행: [1, 1, 1] + [10, 20, 30]
# 2행: [2, 2, 2] + [10, 20, 30]
# 3행: [3, 3, 3] + [10, 20, 30]
result = matrix + vector

print(f"행렬 Shape: {matrix.shape}")
print(f"벡터 Shape: {vector.shape}")
print(f"브로드캐스팅 결과:\n{result}")
```
